---
title: Creating pools
description: Spin up workers and call tasks.
sidebar:
  order: 2
---

`createPool(options)(tasks)` starts worker threads and returns helpers:

- `call.<task>(args)` enqueue a task and return a promise.
- `shutdown()` stop all workers.

`call.*()` always returns a promise.
Inputs may also be promises; they are resolved on the host before dispatch.
If an input promise rejects, the host call rejects and the worker task is not
executed. If a task returns a promise, `call.*()` resolves/rejects with the
awaited task result.

See [Promise inputs and awaited outputs](/guides/defining-tasks#promise-inputs-and-awaited-outputs).

:::note
`createPool(...)` can only be called from the main thread. Use `isMain` to guard
entrypoints that create pools.
:::

## Options

```ts
createPool({
  threads?: number,
  payloadInitialBytes?: number,
  payloadMaxBytes?: number,
  abortSignalCapacity?: number,
  inliner?: {
    position?: "first" | "last",
    batchSize?: number,
    dispatchThreshold?: number,
  },
  balancer?: {
    strategy?: "roundRobin" | "firstIdle" | "randomLane" | "firstIdleOrRandom"
  } | "roundRobin" | "firstIdle" | "randomLane" | "firstIdleOrRandom",
  worker?: {
    resolveAfterFinishingAll?: true,
    timers?: {
      spinMicroseconds?: number,
      parkMs?: number,
      pauseNanoseconds?: number,
    },
  },
  workerExecArgv?: string[],
  permission?: "strict" | "unsafe" | PermisonProtocol,
  host?: {
    stallFreeLoops?: number,
    maxBackoffMs?: number,
  },
  debug?: {
    extras?: boolean,
    logMain?: boolean,
    logHref?: boolean,
    logImportedUrl?: boolean,
  },
})
```

### threads

Number of worker threads to spawn (default `1`). The total lane count is
`threads + (inliner ? 1 : 0)`.

### payloadInitialBytes

Initial size (in bytes) of each payload `SharedArrayBuffer` used by a worker.
Lower values reduce startup memory; the buffer can grow later (when growable
SAB is supported).

### payloadMaxBytes

Maximum size (in bytes) each payload `SharedArrayBuffer` is allowed to grow to.

### Payload buffer behavior

- Defaults:
  - `payloadMaxBytes = 64 * 1024 * 1024` (`64 MiB`)
  - `payloadInitialBytes = 4 * 1024 * 1024` (`4 MiB`) when SAB growth is available
  - If SAB growth is not available, initial size is forced to max size.
- Validation:
  - Non-finite or `<= 0` values are ignored (defaults used).
  - `payloadInitialBytes` is clamped to `payloadMaxBytes`.
- Scope:
  - Applied per worker and per direction (request payload + return payload), so each worker allocates two payload buffers with these limits.

### abortSignalCapacity

Maximum number of concurrent abort-aware calls the pool can track. Defaults
to `258`. Each call to a task that has `abortSignal` enabled occupies one slot;
when the pool is exhausted the call throws `AbortSignalPoolExhausted`.

Only tasks defined with `abortSignal: true` or `abortSignal: { hasAborted: true }`
count against this limit. Regular tasks (no abort signal) are unaffected.

Increase this if you fire many abort-aware calls concurrently:

```ts
const pool = createPool({
  threads: 4,
  abortSignalCapacity: 1024,
})({ myAbortableTask });
```

## Example

Basic example:

```ts
import { createPool, isMain, task } from "@vixeny/knitting";

export const add = task<[number, number], number>({
  f: async ([a, b]) => a + b,
});

const { call, shutdown } = createPool({
  threads: 2,
})({ add });

if (isMain) {
  const jobs = [call.add([1, 2]), call.add([3, 4])];
  const results = await Promise.all(jobs);
  console.log(results);
  shutdown();
}
```

:::danger
After `shutdown()` runs, in-flight and future `call.*()` promises reject (reason:
`"Thread closed"`).
:::

## balancer

Controls how calls are routed across lanes (threads, plus the optional inliner).
Pass a string or an object with a `strategy` key.

- `roundRobin` (default): round-robin rotation through all lanes.
- `firstIdle`: pick the first idle lane, else fall back to round-robin.
- `randomLane`: pick a random lane.
- `firstIdleOrRandom`: pick the first idle lane, else random.

:::note
`robinRound` is accepted as a legacy alias for `roundRobin`.
:::

When only one thread is spawned and no inliner is enabled, the balancer is
bypassed entirely and calls go directly to the single worker.

## inliner

Adds an extra lane that runs tasks on the main thread.

- `position`: whether the inline lane appears before (`"first"`) or after
  (`"last"`) the worker lanes for balancing purposes.
- `batchSize`: max tasks processed per event-loop tick (default `1` when enabled).
- `dispatchThreshold`: minimum in-flight calls per task invoker before the
  inline lane is eligible (default `1`).
  Below the threshold, only worker lanes are scheduled; at/above it, workers
  plus inline lane are scheduled.
  This option has effect only when `inliner` is enabled.

See [Inliner guide](/guides/inliner) for more detail.

## worker

### resolveAfterFinishingAll

When set to `true`, makes workers wait for all pending promises to settle
before exiting. Useful when tasks spawn background work that should complete
before shutdown.

### timers

Idle behavior tuning. These affect how workers spin, pause, and park when there
is no work.

#### spinMicroseconds

Busy-spin budget before the worker parks (microseconds). Larger values can
reduce latency under bursty load but increase CPU usage.

Defaults to `max(1, totalLanes) * 35`, where `totalLanes = threads + (inliner ? 1 : 0)`.

#### parkMs

`Atomics.wait` timeout while parked (milliseconds). Smaller values wake more
often (lower latency, higher overhead); larger values sleep longer (lower
overhead, potentially higher latency).

Defaults to `max(1, totalLanes) * 50`.

#### pauseNanoseconds

`Atomics.pause` duration while spinning (nanoseconds). Use this to reduce power
draw / contention during spin loops. Set to `0` (or less) to disable pause calls.

## workerExecArgv

Extra Node.js `execArgv` flags passed to worker threads, for example
`["--expose-gc"]`. Defaults to `process.execArgv` plus `--expose-gc` when
the current Node.js binary supports that flag.

Knitting deduplicates and validates flags against
`process.allowedNodeEnvironmentFlags` before passing them to the worker.

When `permission` is set to `"unsafe"`, Node.js permission flags
(`--allow-fs-read`, `--allow-fs-write`, etc.) are automatically stripped from
the inherited argv so they do not conflict.

```ts
const pool = createPool({
  threads: 2,
  workerExecArgv: ["--expose-gc", "--max-old-space-size=4096"],
})({ myTask });
```

## permission

Runtime permission protocol that restricts what workers can access.
Accepts a shorthand string or a full configuration object.

- `"strict"` (default when an object is passed): deny access to sensitive
  paths and environment variables by default.
- `"unsafe"`: strip all permission flags (workers run unrestricted).

Object form for fine-grained control:

```ts
createPool({
  threads: 2,
  permission: {
    mode: "strict",
    console: true,
    cwd: "/app",
    read: ["./data"],
    write: ["./output"],
    denyRead: [".env", ".git"],
    denyWrite: ["/etc"],
    env: { allow: ["NODE_ENV", "PORT"] },
    node: { worker: true, childProcess: false },
  },
})({ myTask });
```

See [Permissions guide](/guides/permissions) for the full reference (modes,
allow/deny lists, runtime-specific settings, and strict-mode defaults).

## host

Host dispatcher backoff and scheduling options.

### stallFreeLoops

How many immediate notify loops run before backoff kicks in (default `128`).

### maxBackoffMs

Maximum backoff delay in milliseconds once the dispatcher starts stalling
(default `10`).

## debug

### extras

Enables extra warnings (for example, if `createPool` is accidentally called in a
worker thread).

### logMain

Enables signal logging on the main thread. This writes log files under `./log/`.

### logHref

Logs the worker entry module URL used to spawn workers.
Useful when auditing module resolution (for example `task({ href })` overrides).

### logImportedUrl

Logs the list of module URLs that workers import to discover tasks.

## Limits

A single pool supports up to **65,536 tasks** (function IDs are stored as
`Uint16`, range `0..0xFFFF`). Passing more tasks throws a `RangeError`.