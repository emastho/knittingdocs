---
title: Physics loop
description: "2D random walk simulation -- branch-heavy physics loop parallelized across workers"
hero:
  title: 'Parallel Monte Carlo Physics Loop'
sidebar:
  order: 3

---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../components/RuntimeRunTabs.astro';

export const run = getCode("maths/physics_style_loops/walks_runs.ts");
export const walk_chunk = getCode("maths/physics_style_loops/walk2d.ts");

A physics-style simulation loop: step-by-step state updates with branching and early exits. Unlike the pi example (pure arithmetic), this one simulates a **2D random walk** -- start at the origin, move one unit in a random direction each step, stop when the particle crosses a radius boundary. The work per trial varies (some particles escape early, some don't), which makes chunking important for load balance.

## How it works

1. The host creates a pool and splits the total run count into chunks.
2. Each worker runs many independent particle trials in a tight inner loop:
   - Initialize `(x, y)` at the origin
   - Each step: pick a random direction, update position, check escape condition
   - Track whether the particle escaped and how many steps it took
3. Each chunk returns **compact summary stats**: escaped count, total runs, sum of escape steps.
4. The host aggregates chunk results into final estimates.

We measure two things:

- **Escape probability:** what fraction of particles reached the boundary within `maxSteps`?
- **Mean escape time:** how many steps did it take (for particles that escaped)?

## Install

:::info
<LibraryInstallTabs jsrPackages={["@vixeny/knitting"]} denoUseNpmInterop={true} />
:::

## Run

:::info
<RuntimeRunTabs
  bunCommand="bun src/walks_runs.ts --threads 6 --runs 15000000 --batch 5000 --steps 15000 --radius 100"
  denoCommand="deno run -A src/walks_runs.ts --threads 6 --runs 15000000 --batch 5000 --steps 15000 --radius 100"
  nodeCommand="npx tsx src/walks_runs.ts --threads 6 --runs 15000000 --batch 5000 --steps 15000 --radius 100"
/>
:::

Expected output:

```
threads: 6  runs: 15,000,000  batch: 5,000  steps: 15,000  radius: 100

escape probability: 0.9847
mean escape steps:  7,312
elapsed: 3.41s
```

:::note
With `--radius 100` and `--steps 15000`, most particles escape. Increase the radius or decrease max steps to see the escape probability drop.
:::

## Code
<Tabs>
  <TabItem label="walks_runs.ts">
    <Code code={run} lang="ts" title={"walks_runs.ts"} />
  </TabItem>
  <TabItem label="walk2d.ts">
    <Code code={walk_chunk} lang="ts" title={"walk2d.ts"} />
  </TabItem>
</Tabs>

## What makes this different from the pi example

The pi example does the same amount of work per sample (two multiplies and a compare). This simulation has **variable work per trial** -- particles that escape early are cheap, particles that hit the step limit are expensive. That variability means chunking matters more: well-sized chunks smooth out the variance so no single worker gets stuck with all the hard trials.

The inner loop is also branch-heavy (escape checks, direction selection), which is closer to real simulation code than a pure arithmetic kernel.

## The science

This is a discrete-time approximation of **Brownian motion** / **diffusion**. The estimates converge by the Law of Large Numbers, and Monte Carlo error shrinks like `1/sqrtN`.

$$
\hat{p} = \frac{\text{escaped}}{\text{total runs}} \qquad \hat{\mu} = \frac{\sum \text{steps}}{\text{escaped}}
$$

Real applications of this pattern: diffusion/Brownian motion, hitting time problems, Monte Carlo transport (particles through materials), agent-based models, game simulation, and uncertainty propagation.

## Practical notes

**Chunk size:** Start with `--batch 5000` to `50000` for heavier loops. Increase if each run is short, decrease if each run is long.

**Keep the inner loop tight:** Avoid allocations per step. Precompute direction tables if possible. Use simple numeric types.

**Validate invariants:** Check that `0 <= escaped <= totalRuns`, totals add up across chunks, and results are stable under fixed seeds.

## Things to try

1. Increase `--radius` and see how mean escape steps changes.
2. Compare different `--batch` chunk sizes and measure throughput.
3. Add variance reporting and compute a 95% confidence interval.
4. Replace the random walk with a drift term (constant force) and compare escape behavior.