---
title: Big prime
description: "Parallel prime search through large integers with Miller-Rabin"
hero:
  title: 'Prime Hunt in Big-Number Territory'
sidebar:
  order: 1
banner:
  content: |
    This example could be improved with ` signals `
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../components/RuntimeRunTabs.astro';

export const run = getCode("maths/big_prime/run_prime.hunt.ts");
export const prime_scan = getCode("maths/big_prime/prime_scan.ts");

Scans through large integers (default: 1500-bit) looking for probable primes using Miller-Rabin, distributed across Knitting workers. This is a long-running compute pipeline -- it scans windows of candidates, prints progress, and keeps going until you stop it.

## How it works

1. The host picks a starting odd integer in the chosen bit-width.
2. It scans **windows** of 10,000,000 odd candidates, printing progress after each window.
3. Each window is split across threads -- threads scan disjoint candidate sequences (no overlap, no duplicated work).
4. Each worker runs `candidate -> Miller-Rabin -> next candidate -> ...` in a tight loop.
5. If any worker finds a probable prime, it reports it for that window.
6. The process runs continuously until Ctrl+C.

The scanning uses an interleaved stride pattern: thread 0 checks `start + 0`, `start + 2T`, `start + 4T`, ..., thread 1 checks `start + 2`, `start + 2 + 2T`, ..., and so on. This guarantees full coverage with zero overlap.

## Install

:::info
<LibraryInstallTabs jsrPackages={["@vixeny/knitting"]} denoUseNpmInterop={true} />
:::

## Run

:::info
<RuntimeRunTabs
  bunCommand="bun src/run_prime_hunt.ts --threads 4 --bits 1500 --total 10000000 --chunk 200000 --rounds 8"
  denoCommand="deno run -A src/run_prime_hunt.ts --threads 4 --bits 1500 --total 10000000 --chunk 200000 --rounds 8"
  nodeCommand="npx tsx src/run_prime_hunt.ts --threads 4 --bits 1500 --total 10000000 --chunk 200000 --rounds 8"
/>
:::

Expected output:

```
starting at 1500-bit odd integer (4 threads, 8 MR rounds)
window 1: scanned 10,000,000 candidates in 4.2s -- no prime found
window 2: scanned 10,000,000 candidates in 4.1s -- no prime found
window 3: scanned 10,000,000 candidates in 4.3s -- OK probable prime found!
  digits: 452
  hex prefix: 0xA3F7...
```

:::note
At 1500 bits, primes are sparse -- expect to scan through many windows. Lower `--bits` to 65 or 128 for faster results while testing.
:::

## Code
<Tabs>
  <TabItem label="run.ts">
    <Code code={run} lang="ts" title={"run.ts"} />
  </TabItem>
    <TabItem label="prime_scan.ts">
    <Code code={prime_scan} lang="ts" title={"prime_scan.ts"} />
  </TabItem>
</Tabs>

## The math behind it

**Why primes are findable:** Around a number of size N, prime density is roughly `1/ln(N)`. Primes get rarer as numbers get bigger, but not impossibly rare -- even at 1500 bits, you'll find them.

**Probable vs proven primes:** Miller-Rabin is a probabilistic test. With 8 rounds, the false-positive rate is vanishingly small (less than `4^-8`). In practice, this is what cryptographic libraries use for key generation.

**Tuning `--rounds`:** More rounds = higher confidence, but more compute per candidate. 8 rounds is a solid default. You can go higher if you need cryptographic-grade confidence.

## CLI knobs

- `--bits` -- bit-width of candidates (higher = harder, sparser primes)
- `--threads` -- worker count
- `--total` -- candidates per window (controls progress granularity)
- `--chunk` -- candidates per task (controls scheduling granularity)
- `--rounds` -- Miller-Rabin rounds (controls confidence vs speed)

## Things to try

1. Lower `--bits` to 65 and watch primes appear frequently.
2. Increase `--rounds` to 20 and measure the throughput impact.
3. Compare different `--chunk` values -- too small and dispatch overhead dominates, too large and load balance suffers.
4. Modify the task to search for twin primes (p and p+2 both prime) or Sophie Germain primes (p and 2p+1 both prime).