---
title: JWT revalidation
description: Verify JWTs and optionally reissue them using Web Crypto -- no external JWT library needed.
hero:
  title: 'JWT validation + renewal'
sidebar:
  order: 2
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const run = getCode("data_transforms/jwt_revalidation/jwt_knitting.ts");
export const bench = getCode("data_transforms/jwt_revalidation/bench_jwt_revalidation.ts");
export const utils = getCode("data_transforms/jwt_revalidation/utils.ts");

Verifies JWT signatures with HMAC SHA-256, checks expiry, and optionally reissues tokens -- all using built-in Web Crypto, no external JWT package. This example shows what it looks like to offload auth-related crypto work to a worker pool.

## How it works

The host builds a batch of JWTs (mix of valid and expired). Each job verifies the signature, checks the renewal window (`renewWindowSec`, `renewUntil`), and either returns the validated claims or issues a fresh token. The result comes back as a stringified JSON response -- keeping structured-clone overhead low.

Three files:

- `jwt_knitting.ts` -- runs revalidation in host and Knitting modes
- `utils.ts` -- token verification, renewal logic, task exports
- `bench_jwt_revalidation.ts` -- host-vs-worker benchmark with `mitata`

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["mitata"]}
  denoUseNpmInterop={true}
/>
:::

Uses built-in Web Crypto APIs -- no extra JWT package required.

## Run

:::info
<RuntimeRunTabs
  bunCommand="bun src/jwt_knitting.ts"
  denoCommand="deno run -A src/jwt_knitting.ts"
  nodeCommand="npx tsx src/jwt_knitting.ts"
/>
:::

Expected output:

```
-- host mode --
  verified: 900  renewed: 80  rejected: 20

-- knitting mode (2 threads) --
  verified: 900  renewed: 80  rejected: 20
```

## Benchmark

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_jwt_revalidation.ts"
  nodeCommand="npx tsx src/bench_jwt_revalidation.ts"
/>
:::

Compares verify + optional renewal + `JSON.stringify` via direct imports (`host`) against the same workload through worker task calls (`knitting`). Batched dispatch keeps the comparison stable.

:::note
Both paths use the same logic. The only variable is whether execution happens on the main thread or in a worker.
:::

## Code

<Tabs>
  <TabItem label="jwt_knitting.ts">
    <Code code={run} lang="ts" title={"jwt_knitting.ts"} />
  </TabItem>
  <TabItem label="bench_jwt_revalidation.ts">
    <Code code={bench} lang="ts" title={"bench_jwt_revalidation.ts"} />
  </TabItem>
  <TabItem label="utils.ts">
    <Code code={utils} lang="ts" title={"utils.ts"} />
  </TabItem>
</Tabs>

## Why offload JWT work

HMAC verification and key derivation are CPU-bound. On a busy API server handling hundreds of authenticated requests per second, that crypto work competes with route handling on the main thread. Moving it to a pool keeps your event loop responsive -- especially under mixed traffic where some routes are cheap and others hit the auth path hard.