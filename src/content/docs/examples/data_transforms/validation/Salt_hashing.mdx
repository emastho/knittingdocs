---
title: Salt hashing
description: PBKDF2 password hashing with constant-time verification -- the heaviest per-call workload in the validation set.
hero:
  title: 'Salting + hashing'
sidebar:
  order: 3
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const run = getCode("data_transforms/salt_hashing/salt_knitting.ts");
export const bench = getCode("data_transforms/salt_hashing/bench_salt_hashing.ts");
export const utils = getCode("data_transforms/salt_hashing/utils.ts");

Derives password hashes with PBKDF2-SHA256 and verifies them with constant-time comparison. This is the heaviest per-call workload in the validation set -- each hash derivation is genuinely CPU-expensive by design (that's the point of PBKDF2).

## How it works

1. Generate a random salt per password.
2. Derive a hash using `PBKDF2-SHA256` via Web Crypto.
3. Store as a compact record: `algorithm$iterations$keyBytes$salt$hash`.
4. Verify login attempts by recomputing and constant-time comparing.

The benchmark uses `Uint8Array` payloads to reduce serialization noise in hot loops.

Three files:

- `salt_knitting.ts` -- runs salting + verification in host and Knitting modes
- `utils.ts` -- hashing, verification, and fast-path packet functions
- `bench_salt_hashing.ts` -- host-vs-worker benchmark with `mitata`

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["mitata"]}
  denoUseNpmInterop={true}
/>
:::

Uses built-in Web Crypto APIs -- no extra crypto package required.

## Run

:::info
<RuntimeRunTabs
  bunCommand="bun src/salt_knitting.ts"
  denoCommand="deno run -A src/salt_knitting.ts"
  nodeCommand="npx tsx src/salt_knitting.ts"
/>
:::

Expected output:

```
-- host mode --
  hashed: 100  verified: 100  mismatches: 0

-- knitting mode (2 threads) --
  hashed: 100  verified: 100  mismatches: 0
```

## Benchmark

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_salt_hashing.ts"
  nodeCommand="npx tsx src/bench_salt_hashing.ts"
/>
:::

Compares hashing typed-array packets through direct imports (`host`) vs worker task calls (`knitting`). Because PBKDF2 is intentionally slow (high iteration count), this is where workers shine most -- each call does enough real work to easily justify dispatch overhead.

## Code

<Tabs>
  <TabItem label="salt_knitting.ts">
    <Code code={run} lang="ts" title={"salt_knitting.ts"} />
  </TabItem>
  <TabItem label="bench_salt_hashing.ts">
    <Code code={bench} lang="ts" title={"bench_salt_hashing.ts"} />
  </TabItem>
  <TabItem label="utils.ts">
    <Code code={utils} lang="ts" title={"utils.ts"} />
  </TabItem>
</Tabs>

## The ideal offload candidate

Password hashing is one of those tasks where workers are almost always worth it. The work is CPU-bound, each call is independent, the input and output are small, and -- critically -- you *want* it to be slow (high iterations = harder to brute force). That's a perfect storm for offloading: expensive per-call work that would otherwise block your event loop during login/signup spikes.