---
title: Hono server routes
description: Build a Hono server with ping, SSR, and JWT routes in Knitting or host-only mode.
hero:
  title: 'Hono + SSR + JWT'
sidebar:
  order: 4
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const server = getCode("data_transforms/hono_server/hono_knitting.ts");
export const renderSsrPage = getCode("data_transforms/hono_server/hono_componets_ssr.tsx");
export const issueJwt = getCode("data_transforms/hono_server/hono_components_jwt.ts");

## What is this about

This example builds a small Hono API with 3 routes:

1. `GET /ping` for health checks.
2. `POST /ssr` to SSR a user card.
3. `POST /jwt` to issue a valid signed JWT for a user.

This example is split into three files:

1. `hono_knitting.ts` (the Hono server, plus a Knitting worker pool).
2. `hono_componets_ssr.tsx` (SSR task: parse + defaults + render).
3. `hono_components_jwt.ts` (JWT task: validate + sign + return JSON string).

## Technologies used (and why)

- **Hono**: a small, fast routing layer. It keeps the request path minimal so most overhead is in your actual route work.
- **`@hono/node-server`**: a thin adapter that runs a Hono `fetch` handler on Node/Bun.
- **React SSR (`react-dom/server`)**: renders a tiny HTML page for `/ssr` so you can simulate CPU-heavy server work.
- **`hono/jwt`**: signs a JWT (HS256) for `/jwt` so the example includes common auth-like CPU work.
- **Knitting (`@vixeny/knitting`)**: runs selected transforms in a worker pool (threads). This is the core “offload expensive work” technique the example demonstrates.

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["hono", "@hono/node-server", "react", "react-dom", "zod"]}
  denoUseNpmInterop={true}
/>
:::

The JWT route uses `hono/jwt` and signs with HS256.
Set `JWT_SECRET` in production.

## Deno setup (TSX + npm)

This example imports TSX and npm packages. For Deno, keep a root `deno.json`
like this:

```json
{
  "nodeModulesDir": "auto",
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react"
  }
}
```

Without this, TSX files can fail with:

```txt
Uncaught SyntaxError: Unexpected token '<'
```

## Run

:::info
<RuntimeRunTabs
  bunLabel="Bun (Knitting)"
  bunCommand='JWT_SECRET="replace-me" bun src/hono_knitting.ts'
  denoCommand='JWT_SECRET="replace-me" deno run -A src/hono_knitting.ts'
/>
:::

## Route quick checks

```bash
# Ping
curl -s http://localhost:3000/ping

# SSR (returns HTML)
curl -s http://localhost:3000/ssr \
  -H 'content-type: application/json' \
  -d '{"name":"Ari","plan":"pro","bio":"Building on Knitting","projects":17}'

# JWT (returns JSON string with token)
curl -s http://localhost:3000/jwt \
  -H 'content-type: application/json' \
  -d '{"user":{"id":"u_42","email":"ari@example.com","role":"admin"},"ttlSec":900}'
```

## Performance notes (how to talk about it correctly)

### What the numbers say (hono_only → hono+knitting)

#### Throughput (RPS)

| Route | Hono only | Hono + Knitting | Delta |
| --- | ---: | ---: | ---: |
| `/ping` | `2998` | `5471` | **+82%** |
| `/ssr` | `2998` | `5421` | **+81%** |
| `/jwt` | `2916` | `5454` | **+87%** |

So: roughly **~1.8× throughput** across the board. Offloading the heavy work frees the main thread, so even the “cheap” routes handle more requests per second when Knitting is in play.

### Latency improvements (lower is better)

#### PING

| Percentile | Hono only | Hono + Knitting | Delta |
| --- | ---: | ---: | ---: |
| `p50` | `16.32ms` | `8.84ms` | **-46%** |
| `p99` | `27.05ms` | `14.52ms` | **-46%** |
| `p99.9` | `71.01ms` | `64.59ms` | **-9%** |
| `p99.99` | `128.70ms` | `99.44ms` | **-23%** |
| `slowest` | `129.25ms` | `99.90ms` | **-23%** |

#### SSR

| Percentile | Hono only | Hono + Knitting | Delta |
| --- | ---: | ---: | ---: |
| `p50` | `16.32ms` | `8.71ms` | **-47%** |
| `p99` | `27.32ms` | `17.35ms` | **-36%** |
| `p99.9` | `71.96ms` | `63.97ms` | **-11%** |
| `p99.99` | `128.61ms` | `98.75ms` | **-23%** |
| `slowest` | `129.31ms` | `106.73ms` | **-17%** |

#### JWT

| Percentile | Hono only | Hono + Knitting | Delta |
| --- | ---: | ---: | ---: |
| `p50` | `16.47ms` | `8.71ms` | **-47%** |
| `p99` | `34.49ms` | `15.91ms` | **-54%** |
| `p99.9` | `114.95ms` | `59.48ms` | **-48%** |
| `p99.99` | `121.47ms` | `101.07ms` | **-17%** |
| `slowest` | `161.28ms` | `138.48ms` | **-14%** |

Headline: the median and `p99` basically halve, and the JWT tail (`p99.9`) improves dramatically.

## Why this pattern matters

- `ping` stays cheap and synchronous.
- You can benchmark workers vs host-only with the same route behavior.
- In Knitting mode, the JWT task returns **stringified JSON** to reduce structured-clone overhead.
- Heavy route logic stays in one shared file, keeping both server entrypoints small.

## Code

<Tabs>
  <TabItem label="hono_knitting.ts">
    <Code code={server} lang="ts" title={"hono_knitting.ts"} />
  </TabItem>
  <TabItem label="hono_componets_ssr.tsx">
    <Code code={renderSsrPage} lang="tsx" title={"hono_componets_ssr.tsx"} />
  </TabItem>
  <TabItem label="hono_components_jwt.ts">
    <Code code={issueJwt} lang="ts" title={"hono_components_jwt.ts"} />
  </TabItem>
</Tabs>
