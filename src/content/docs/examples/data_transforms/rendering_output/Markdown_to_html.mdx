---
title: Markdown to HTML
description: Convert markdown to HTML with Brotli compression -- a simple transform pipeline.
hero:
  title: 'Markdown rendering'
sidebar:
  order: 3
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const bench = getCode("data_transforms/markdown_to_html/bench_markdown_to_html.ts");
export const utils = getCode("data_transforms/markdown_to_html/utils.ts");

Converts markdown documents to HTML using `marked`, then compresses the output with Brotli. A straightforward transform pipeline -- parse, render, compress -- that shows how well workers handle chained operations.

## How it works

The host generates markdown documents. Both the host and worker paths parse the markdown, render HTML, then Brotli-compress the result. Compressed byte totals are compared for parity before the benchmark runs.

Two files:

- `bench_markdown_to_html.ts` -- the host-vs-worker benchmark
- `utils.ts` -- markdown rendering, compression tasks, and shared helpers

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["marked", "mitata"]}
  denoUseNpmInterop={true}
/>
:::

## Benchmark

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_markdown_to_html.ts"
  denoCommand="deno run -A src/bench_markdown_to_html.ts"
/>
:::

Expected output:

```
byte parity check: host=18,720  worker=18,720  OK match

benchmark        avg (ns)    min ... max (ns)
host              32,100     29,400 ... 41,200
knitting          17,800     15,600 ... 24,300
```

## Code

<Tabs>
  <TabItem label="bench_markdown_to_html.ts">
    <Code code={bench} lang="ts" title={"bench_markdown_to_html.ts"} />
  </TabItem>
  <TabItem label="utils.ts">
    <Code code={utils} lang="ts" title={"utils.ts"} />
  </TabItem>
</Tabs>

## A clean pipeline example

This is the simplest rendering example -- no component tree, no JSX, just string in, string out. It's a good reference if you want to understand the worker pattern without the React SSR complexity. The same approach works for any transform chain: parse input, process it, compress or encode the result.