---
title: React SSR
description: Render React components to HTML strings on workers -- the example closest to a real server workload.
hero:
  title: 'React SSR'
sidebar:
  order: 1

---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { getCode } from '../../../../../lib/code-snippets';
import DontDoubleParseTip from '../../../../../components/tips/DontDoubleParseTip.astro';
import LibraryInstallTabs from '../../../../../components/LibraryInstallTabs.astro';
import RuntimeRunTabs from '../../../../../components/RuntimeRunTabs.astro';

export const bench = getCode("data_transforms/react_ssr/bench_react_ssr.ts");
export const component = getCode("data_transforms/react_ssr/render_user_card.tsx");
export const utils = getCode("data_transforms/react_ssr/utils.ts");

Renders React components to HTML strings on workers using `renderToString`. If your server does SSR, this is probably the example closest to your real workload -- parse JSON input, normalize data, render a component, return HTML.

## How it works

The host generates JSON payload strings. The host path calls `renderUserCardHost` directly (parse + normalize + `renderToString`). The worker path sends the same payloads through `createPool`. Byte totals are compared once to verify the host and worker produce identical output, then `mitata` benchmarks both paths.

Three files:

- `bench_react_ssr.ts` -- the benchmark itself
- `render_user_card.tsx` -- the SSR component and worker task
- `utils.ts` -- input payloads and normalization helpers

## Install

:::info
<LibraryInstallTabs
  jsrPackages={["@vixeny/knitting"]}
  npmPackages={["react", "react-dom", "mitata"]}
  denoUseNpmInterop={true}
/>
:::

## Deno setup (TSX + npm)

If you run this with Deno and see `Uncaught SyntaxError: Unexpected token '<'`, set a root `deno.json` so Deno transpiles TSX and resolves npm packages:

```json
{
  "nodeModulesDir": "auto",
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react"
  }
}
```

## Benchmark

:::info
<RuntimeRunTabs
  bunCommand="bun src/bench_react_ssr.ts"
  denoCommand="deno run -A src/bench_react_ssr.ts"
/>
:::

Expected output:

```
byte parity check: host=284,160  worker=284,160  OK match

benchmark        avg (ns)    min ... max (ns)
host              18,200     16,800 ... 24,500
knitting           9,400      8,600 ... 14,100
```

:::note
The byte parity check runs once before benchmarking to confirm host and worker produce identical HTML. If it doesn't match, something is wrong with your setup.
:::

<DontDoubleParseTip />

## Code
<Tabs>

  <TabItem label="bench_react_ssr.ts">
    <Code code={bench} lang="ts" title={"bench_react_ssr.ts"} />
  </TabItem>
  <TabItem label="render_user_card.tsx">
    <Code code={component} lang="tsx" title={"render_user_card.tsx"} />
  </TabItem>
  <TabItem label="utils.ts">
    <Code code={utils} lang="ts" title={"utils.ts"} />
  </TabItem>
</Tabs>

## Why SSR is a great fit for workers

`renderToString` is synchronous and CPU-bound -- it walks your component tree and builds an HTML string. On a request-per-request basis it's not usually slow, but under load it blocks the event loop and everything else waits. Moving SSR to a worker pool means your main thread stays free to accept requests and handle I/O while rendering happens in parallel. The Hono server example shows what this looks like in a real HTTP server context.