<div class="ashes-container" data-ashes aria-hidden="true">
  <canvas class="ashes-canvas ashes-canvas--back" data-ashes-back></canvas>
  <canvas class="ashes-canvas ashes-canvas--front" data-ashes-front></canvas>
</div>

<script>
  const BASE_PARTICLES = 58;
  const FRAME_MS = 1000 / 30;
  const MAX_DPR = 2;
  const FRONT_LAYER_RATIO = 0.06;
  const FRONT_LAYER_Z_BOOST = 10;

  /**
   * @typedef {() => void} CleanupFn
   * @typedef {[number, number, number]} RgbColor
   * @typedef {{ x: number, y: number }} Point
   * @typedef {{
   *   x: number,
   *   y: number,
   *   a: number,
   *   r: number,
   *   g: number,
   *   b: number,
   *   tailAlpha: number,
   *   isFrontLayer: boolean,
   *   z: number,
   *   dp: Point[]
   * }} Particle
   * @typedef {{
   *   x?: number,
   *   y?: number,
   *   a?: number,
   *   dp?: Point[],
   *   isFrontLayer?: boolean
   * }} AshOptions
   */

  /** @type {NodeListOf<HTMLDivElement>} */
  const containers = document.querySelectorAll('[data-ashes]');
  /** @type {WeakMap<HTMLDivElement, CleanupFn>} */
  const containerCleanups = new WeakMap();

  /**
   * @param {string | null} value
   * @returns {string | null}
   */
  function normalizeHexColor(value) {
    if (!value) return null;
    const trimmed = value.trim();
    const match = trimmed.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
    return match ? match[0] : null;
  }

  /**
   * @param {number} value
   * @returns {number}
   */
  function clampColor(value) {
    return Math.max(0, Math.min(255, value));
  }

  /**
   * @returns {RgbColor}
   */
  function hexToRgb() {
    const rootStyles = getComputedStyle(document.documentElement);
    const raw = rootStyles.getPropertyValue('--ashes');
    let hexColor = normalizeHexColor(raw);

    if (!hexColor) hexColor = '#9aa1ab';

    let hex = hexColor.replace(/^#/, '');
    if (hex.length === 3) {
      hex = [...hex].map((x) => x + x).join('');
    }

    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);

    return [r, g, b];
  }

  /**
   * @param {number} width
   * @param {number} height
   * @returns {number}
   */
  function getParticleCount(width, height) {
    const area = Math.max(1, width * height);
    const areaScale = Math.min(1.25, Math.max(0.6, area / (1280 * 720)));
    let count = Math.round(BASE_PARTICLES * areaScale);

    const memory = typeof navigator.deviceMemory === 'number' ? navigator.deviceMemory : null;
    const cores =
      typeof navigator.hardwareConcurrency === 'number' ? navigator.hardwareConcurrency : null;

    if ((memory !== null && memory <= 4) || (cores !== null && cores <= 4)) {
      count = Math.min(count, 28);
    }

    return Math.max(0, count);
  }

  /**
   * @param {HTMLDivElement} container
   * @returns {CleanupFn}
   */
  function startAshes(container) {
    const existingCleanup = containerCleanups.get(container);
    if (typeof existingCleanup === 'function') existingCleanup();

    const backCanvas = container.querySelector('[data-ashes-back]');
    const frontCanvas = container.querySelector('[data-ashes-front]');
    if (!(backCanvas instanceof HTMLCanvasElement) || !(frontCanvas instanceof HTMLCanvasElement)) {
      return () => {};
    }

    const backCtx = backCanvas.getContext('2d', { alpha: true });
    const frontCtx = frontCanvas.getContext('2d', { alpha: true });
    if (!backCtx || !frontCtx) return () => {};

    let W = 1;
    let H = 1;
    let dpr = 1;
    let angle = 0;
    let rgb = hexToRgb();
    /** @type {Particle[]} */
    const A = [];

    // Keep original fade-in behavior so particles do not pop all at once.
    const incr = ((n) => () => (n < 0.7 ? (n = 0.00008 + n) : n))(0);

    let rafId = 0;
    let lastTs = 0;

    /**
     * @param {number} from
     * @param {number} to
     * @param {number} [seed]
     * @returns {number}
     */
    function randomRange(from, to, seed) {
      const source = typeof seed === 'number' ? seed : Math.random();
      return Math.floor(source * (to - from + 1) + from);
    }

    /**
     * @param {Particle} particle
     * @param {number} [seed]
     * @returns {void}
     */
    function recolorParticle(particle, seed) {
      const m = typeof seed === 'number' ? seed : Math.random();
      particle.r = clampColor(randomRange(rgb[0] - 10, rgb[0], m));
      particle.g = clampColor(randomRange(rgb[1] - 10, rgb[1], m));
      particle.b = clampColor(randomRange(rgb[2] - 10, rgb[2], m));
    }

    /**
     * @param {Particle} particle
     * @param {boolean} isFrontLayer
     * @returns {void}
     */
    function setParticleLayer(particle, isFrontLayer) {
      particle.isFrontLayer = isFrontLayer;
      particle.z = particle.a + (isFrontLayer ? FRONT_LAYER_Z_BOOST : 0);
    }

    function rebalanceFrontLayer() {
      if (A.length === 0) return;

      const targetFront = Math.max(0, Math.round(A.length * FRONT_LAYER_RATIO));
      /** @type {Particle[]} */
      const front = [];
      /** @type {Particle[]} */
      const back = [];

      for (let i = 0; i < A.length; i++) {
        if (A[i].isFrontLayer) front.push(A[i]);
        else back.push(A[i]);
      }

      if (front.length > targetFront) {
        const toDemote = front.length - targetFront;
        for (let i = 0; i < toDemote; i++) {
          setParticleLayer(front[i], false);
        }
      } else if (front.length < targetFront) {
        const toPromote = Math.min(targetFront - front.length, back.length);
        for (let i = 0; i < toPromote; i++) {
          setParticleLayer(back[i], true);
        }
      }
    }

    /**
     * @param {AshOptions} [options]
     * @returns {Particle}
     */
    function createAsh(options = {}) {
      const seed = Math.random();
      const pointCount = randomRange(4, 8, seed);
      /** @type {Particle} */
      const particle = {
        x: typeof options.x === 'number' ? options.x : seed * W,
        y: typeof options.y === 'number' ? options.y : seed * H,
        a: typeof options.a === 'number' ? options.a : seed * (pointCount - 4) + 1,
        r: 0,
        g: 0,
        b: 0,
        tailAlpha: randomRange(1, 10, seed) / 10,
        isFrontLayer: false,
        z: 0,
        dp: [],
      };

      recolorParticle(particle, seed);
      setParticleLayer(particle, Boolean(options.isFrontLayer));

      if (options.dp) {
        particle.dp = options.dp;
      } else {
        particle.dp = [{ x: 0, y: 0 }];
        for (let i = 0; i < pointCount; i++) {
          const direction = i === 0 || pointCount / 2 > i ? 1 : -1;
          particle.dp.push({
            x: particle.dp[i].x + randomRange(5, 30) * direction,
            y: particle.dp[i].y + randomRange(5, 30) * direction,
          });
        }
      }

      return particle;
    }

    function syncParticleCount() {
      const target = getParticleCount(W, H);

      if (target > A.length) {
        const isInitialFill = A.length === 0;
        while (A.length < target) {
          A.push(isInitialFill ? createAsh() : createAsh({ y: -10 }));
        }
      } else if (target < A.length) {
        A.length = target;
      }

      rebalanceFrontLayer();
    }

    function resize() {
      W = Math.max(1, window.innerWidth | 0);
      H = Math.max(1, window.innerHeight | 0);

      dpr = Math.min(MAX_DPR, window.devicePixelRatio || 1);
      backCanvas.width = Math.round(W * dpr);
      backCanvas.height = Math.round(H * dpr);
      backCanvas.style.width = `${W}px`;
      backCanvas.style.height = `${H}px`;

      frontCanvas.width = Math.round(W * dpr);
      frontCanvas.height = Math.round(H * dpr);
      frontCanvas.style.width = `${W}px`;
      frontCanvas.style.height = `${H}px`;

      backCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      frontCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

      syncParticleCount();
      if (A.length === 0) {
        backCtx.clearRect(0, 0, W, H);
        frontCtx.clearRect(0, 0, W, H);
      }
    }

    function update() {
      angle += 0.01;
      const driftX = Math.sin(angle) * 2;
      const driftY = Math.cos(angle + A.length) + 1;

      for (let i = 0; i < A.length; i++) {
        const p = A[i];

        p.y += driftY + p.a / 2;
        p.x += driftX;

        if (p.x > W + 5 || p.x < -5 || p.y > H) {
          if (i % 3 > 0) {
            A[i] = createAsh({ y: -10, a: p.a, dp: p.dp, isFrontLayer: p.isFrontLayer });
          } else if (driftX > 0) {
            A[i] = createAsh({ x: -5, a: p.a, dp: p.dp, isFrontLayer: p.isFrontLayer });
          } else {
            A[i] = createAsh({ x: W + 5, a: p.a, dp: p.dp, isFrontLayer: p.isFrontLayer });
          }
        }
      }
    }

    function draw() {
      if (A.length === 0) return;

      backCtx.clearRect(0, 0, W, H);
      frontCtx.clearRect(0, 0, W, H);

      for (let i = 0; i < A.length; i++) {
        const p = A[i];
        const targetCtx = p.isFrontLayer ? frontCtx : backCtx;
        const grad = targetCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.a);
        grad.addColorStop(0, `rgba(${p.r}, ${p.g}, ${p.b}, 1)`);
        grad.addColorStop(0.9, `rgba(${p.r}, ${p.g}, ${p.b}, ${p.tailAlpha})`);
        grad.addColorStop(1, `rgba(${p.r}, ${p.g}, ${p.b}, 0)`);

        targetCtx.beginPath();
        targetCtx.moveTo(p.x, p.y);
        for (let j = 1; j < p.dp.length; j++) {
          targetCtx.lineTo(p.x + p.dp[j].x, p.y + p.dp[j].y);
        }
        targetCtx.closePath();
        targetCtx.fillStyle = grad;
        targetCtx.globalAlpha = incr();
        targetCtx.fill();
      }

      update();
      backCtx.globalAlpha = 1;
      frontCtx.globalAlpha = 1;
    }

    /**
     * @param {number} ts
     */
    function frame(ts) {
      if (lastTs === 0 || ts - lastTs >= FRAME_MS) {
        draw();
        lastTs = ts;
      }
      rafId = window.requestAnimationFrame(frame);
    }

    const onResize = () => resize();
    const onVisibility = () => {
      if (document.visibilityState === 'hidden') {
        lastTs = 0;
      }
    };
    const onThemeAttr = () => {
      // Apply new theme color only to newly spawned particles.
      rgb = hexToRgb();
    };

    const themeObserver = new MutationObserver(onThemeAttr);

    resize();
    rafId = window.requestAnimationFrame(frame);

    window.addEventListener('resize', onResize, { passive: true });
    document.addEventListener('visibilitychange', onVisibility);
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-theme'],
    });

    /** @type {CleanupFn} */
    const cleanup = () => {
      window.cancelAnimationFrame(rafId);
      window.removeEventListener('resize', onResize);
      document.removeEventListener('visibilitychange', onVisibility);
      themeObserver.disconnect();
      if (containerCleanups.get(container) === cleanup) {
        containerCleanups.delete(container);
      }
    };

    containerCleanups.set(container, cleanup);
    return cleanup;
  }

  /** @type {CleanupFn[]} */
  const cleanups = [];
  containers.forEach((container) => {
    cleanups.push(startAshes(container));
  });

  const cleanupAll = () => {
    while (cleanups.length) {
      const fn = cleanups.pop();
      if (fn) fn();
    }
  };

  window.addEventListener('pagehide', cleanupAll, { once: true });
  document.addEventListener('astro:before-swap', cleanupAll, { once: true });
</script>

<style>
  :global(:root) {
    --ashes: #9aa1ab;
  }

  :global(:root[data-theme='dark']) {
    --ashes: #828891;
  }

  :global(:root[data-theme='light']) {
    --ashes: #ff9500;
  }

  .ashes-container {
    pointer-events: none;
  }

  .ashes-canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    transform: translate3d(0, 0, 0);
  }

  .ashes-canvas--back {
    z-index: -1;
  }

  .ashes-canvas--front {
    z-index: 10;
  }
</style>
